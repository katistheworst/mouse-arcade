<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ðŸ«§ Mouse's Lava Lamp</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0a0a0f;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    font-family: 'Segoe UI', sans-serif;
    color: #887;
    overflow: hidden;
    user-select: none;
  }
  canvas {
    border-radius: 40px;
    cursor: crosshair;
  }
  .controls {
    position: fixed;
    bottom: 20px;
    display: flex;
    gap: 12px;
    z-index: 10;
  }
  .controls button {
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.15);
    color: #aaa;
    padding: 8px 16px;
    border-radius: 20px;
    cursor: pointer;
    font-size: 13px;
    transition: all 0.3s;
  }
  .controls button:hover {
    background: rgba(255,255,255,0.15);
    color: #fff;
  }
  .controls button.active {
    background: rgba(255,255,255,0.2);
    color: #fff;
    border-color: rgba(255,255,255,0.4);
  }
  .title {
    position: fixed;
    top: 20px;
    font-size: 14px;
    letter-spacing: 2px;
    opacity: 0.4;
  }
</style>
</head>
<body>
<div class="title">ðŸ«§ MOUSE'S LAVA LAMP â€” click to add blobs</div>
<canvas id="c"></canvas>
<div class="controls">
  <button onclick="setTheme(0)" id="t0" class="active">Sunset</button>
  <button onclick="setTheme(1)" id="t1">Ocean</button>
  <button onclick="setTheme(2)" id="t2">Neon</button>
  <button onclick="setTheme(3)" id="t3">Ember</button>
  <button onclick="setTheme(4)" id="t4">Cosmic</button>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

const themes = [
  { name:'Sunset', bg:'#1a0a1e', colors:['#ff6b6b','#ffa07a','#ff4757','#ff6348','#e84393'] },
  { name:'Ocean', bg:'#0a1a2e', colors:['#00b4d8','#0077b6','#48cae4','#90e0ef','#00b894'] },
  { name:'Neon', bg:'#0a0a1e', colors:['#a855f7','#ec4899','#06b6d4','#22d3ee','#f472b6'] },
  { name:'Ember', bg:'#1a0a0a', colors:['#ff4500','#ff6347','#ff8c00','#ffd700','#dc143c'] },
  { name:'Cosmic', bg:'#0a0a18', colors:['#7c3aed','#2563eb','#06b6d4','#8b5cf6','#3b82f6'] },
];

let currentTheme = 0;
let blobs = [];
let W, H;

function resize() {
  const s = Math.min(window.innerWidth * 0.85, window.innerHeight * 0.75);
  W = canvas.width = s;
  H = canvas.height = s * 1.4;
}
resize();
window.addEventListener('resize', resize);

class Blob {
  constructor(x, y, r) {
    this.x = x || W * (0.2 + Math.random() * 0.6);
    this.y = y || H * (0.3 + Math.random() * 0.5);
    this.r = r || 30 + Math.random() * 50;
    this.vx = (Math.random() - 0.5) * 0.3;
    this.vy = -0.2 - Math.random() * 0.4;
    this.phase = Math.random() * Math.PI * 2;
    this.wobbleSpeed = 0.005 + Math.random() * 0.01;
    this.wobbleAmp = 0.15 + Math.random() * 0.15;
    this.color = themes[currentTheme].colors[Math.floor(Math.random() * themes[currentTheme].colors.length)];
    this.opacity = 0.6 + Math.random() * 0.3;
    this.born = Date.now();
  }

  update() {
    this.phase += this.wobbleSpeed;
    const wobble = Math.sin(this.phase) * this.wobbleAmp;

    // Buoyancy â€” rise when warm (bottom), sink when cool (top)
    const centerY = H * 0.5;
    const buoyancy = (this.y - centerY) / H * 0.08;
    this.vy += -buoyancy * 0.1;
    this.vy *= 0.995;
    this.vx += Math.sin(this.phase * 1.3) * 0.01;
    this.vx *= 0.99;

    this.x += this.vx + wobble * 2;
    this.y += this.vy;

    // Boundaries â€” soft bounce
    const pad = this.r + 20;
    if (this.x < pad) { this.x = pad; this.vx *= -0.5; }
    if (this.x > W - pad) { this.x = W - pad; this.vx *= -0.5; }
    if (this.y < pad) { this.y = pad; this.vy *= -0.3; }
    if (this.y > H - pad) { this.y = H - pad; this.vy *= -0.5; }

    // Pulsate radius
    this.drawR = this.r * (1 + Math.sin(this.phase * 0.7) * 0.12);
  }

  draw() {
    const age = Math.min((Date.now() - this.born) / 1000, 1);
    const grad = ctx.createRadialGradient(
      this.x - this.drawR * 0.2, this.y - this.drawR * 0.2, 0,
      this.x, this.y, this.drawR
    );
    grad.addColorStop(0, this.color + hexAlpha(this.opacity * age * 0.9));
    grad.addColorStop(0.6, this.color + hexAlpha(this.opacity * age * 0.5));
    grad.addColorStop(1, this.color + '00');

    ctx.beginPath();
    // Wobbly circle
    for (let a = 0; a < Math.PI * 2; a += 0.1) {
      const wobble = 1 + Math.sin(a * 3 + this.phase) * 0.08 + Math.sin(a * 5 - this.phase * 1.3) * 0.04;
      const px = this.x + Math.cos(a) * this.drawR * wobble;
      const py = this.y + Math.sin(a) * this.drawR * wobble;
      a === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.fillStyle = grad;
    ctx.fill();
  }
}

function hexAlpha(a) {
  return Math.round(Math.min(1, Math.max(0, a)) * 255).toString(16).padStart(2, '0');
}

// Seed initial blobs
for (let i = 0; i < 8; i++) blobs.push(new Blob());

// Merge nearby blobs, split big ones
function blobPhysics() {
  // Attract nearby blobs
  for (let i = 0; i < blobs.length; i++) {
    for (let j = i + 1; j < blobs.length; j++) {
      const dx = blobs[j].x - blobs[i].x;
      const dy = blobs[j].y - blobs[i].y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const minDist = blobs[i].drawR + blobs[j].drawR;

      if (dist < minDist * 1.5 && dist > 0) {
        const force = 0.0005 * (minDist - dist);
        blobs[i].vx += dx / dist * force;
        blobs[i].vy += dy / dist * force;
        blobs[j].vx -= dx / dist * force;
        blobs[j].vy -= dy / dist * force;
      }
    }
  }

  // Spontaneous spawn/removal to keep it interesting
  if (blobs.length < 6 && Math.random() < 0.005) blobs.push(new Blob());
  if (blobs.length > 15 && Math.random() < 0.01) blobs.splice(Math.floor(Math.random() * blobs.length), 1);
}

function draw() {
  const theme = themes[currentTheme];

  // Background with slight gradient
  const bgGrad = ctx.createLinearGradient(0, 0, 0, H);
  bgGrad.addColorStop(0, theme.bg);
  bgGrad.addColorStop(1, lighten(theme.bg, 15));
  ctx.fillStyle = bgGrad;
  ctx.fillRect(0, 0, W, H);

  // Glass effect â€” subtle border glow
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.roundRect(1, 1, W - 2, H - 2, 40);
  ctx.stroke();

  blobPhysics();

  // Use globalCompositeOperation for that gooey merge effect
  ctx.globalCompositeOperation = 'screen';
  for (const b of blobs) {
    b.update();
    b.draw();
  }
  ctx.globalCompositeOperation = 'source-over';

  // Glass reflection overlay
  const refGrad = ctx.createLinearGradient(W * 0.3, 0, W * 0.7, H);
  refGrad.addColorStop(0, 'rgba(255,255,255,0.04)');
  refGrad.addColorStop(0.5, 'rgba(255,255,255,0)');
  refGrad.addColorStop(1, 'rgba(255,255,255,0.02)');
  ctx.fillStyle = refGrad;
  ctx.fillRect(0, 0, W, H);

  requestAnimationFrame(draw);
}

function lighten(hex, amt) {
  let r = parseInt(hex.slice(1,3), 16) + amt;
  let g = parseInt(hex.slice(3,5), 16) + amt;
  let b = parseInt(hex.slice(5,7), 16) + amt;
  return `rgb(${Math.min(255,r)},${Math.min(255,g)},${Math.min(255,b)})`;
}

function setTheme(i) {
  currentTheme = i;
  document.querySelectorAll('.controls button').forEach((b, idx) => b.classList.toggle('active', idx === i));
  // Recolor existing blobs
  for (const b of blobs) {
    b.color = themes[i].colors[Math.floor(Math.random() * themes[i].colors.length)];
  }
}

canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (W / rect.width);
  const y = (e.clientY - rect.top) * (H / rect.height);
  blobs.push(new Blob(x, y, 20 + Math.random() * 40));
});

draw();
</script>
</body>
</html>
