<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mouse's Digital Terrarium üåø</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0a12; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; font-family: 'Courier New', monospace; color: #c8b8e8; overflow: hidden; }
h1 { font-size: 1.2rem; margin-bottom: 8px; letter-spacing: 2px; opacity: 0.7; }
#stats { font-size: 0.75rem; opacity: 0.5; margin-bottom: 8px; }
canvas { border-radius: 16px; cursor: crosshair; box-shadow: 0 0 40px rgba(160, 120, 255, 0.15); }
#controls { margin-top: 12px; display: flex; gap: 10px; }
button { background: rgba(160, 120, 255, 0.15); border: 1px solid rgba(160, 120, 255, 0.3); color: #c8b8e8; padding: 6px 14px; border-radius: 20px; cursor: pointer; font-family: inherit; font-size: 0.75rem; transition: all 0.2s; }
button:hover { background: rgba(160, 120, 255, 0.3); }
#log { font-size: 0.65rem; opacity: 0.4; margin-top: 8px; max-width: 600px; text-align: center; height: 1.2em; }
</style>
</head>
<body>
<h1>üåø digital terrarium üåø</h1>
<div id="stats">loading ecosystem...</div>
<canvas id="c" width="600" height="400"></canvas>
<div id="controls">
<button onclick="sprinkleFood()">üåæ sprinkle food</button>
<button onclick="addCreature()">ü•ö add creature</button>
<button onclick="toggleRain()">üåßÔ∏è rain</button>
<button onclick="toggleTime()">‚òÄÔ∏è day/night</button>
</div>
<div id="log"></div>

<script>
const c = document.getElementById('c');
const ctx = c.getContext('2d');
const W = 600, H = 400;

let tick = 0;
let isNight = true;
let isRaining = false;
let logText = '';
let logTimer = 0;

const names = ['pip','dot','mote','fern','dew','nib','fig','rue','bud','wren','moss','elm','oak','ash','ivy','bay','ori','umi','sol','lux'];
const species = [
  { emoji: 'üêõ', speed: 0.6, size: 4, color: '#88cc66', lifespan: 3000 },
  { emoji: 'üêå', speed: 0.2, size: 5, color: '#cc9966', lifespan: 5000 },
  { emoji: 'ü¶ó', speed: 1.2, size: 3, color: '#66aa88', lifespan: 2000 },
  { emoji: 'üêú', speed: 0.8, size: 3, color: '#aa6644', lifespan: 2500 },
  { emoji: 'ü™±', speed: 0.3, size: 4, color: '#cc88aa', lifespan: 4000 },
  { emoji: 'üêû', speed: 0.7, size: 4, color: '#dd4444', lifespan: 3500 },
];

let creatures = [];
let foods = [];
let plants = [];
let rain = [];
let particles = [];

function log(msg) { logText = msg; logTimer = 180; }

// Generate terrain
let ground = [];
for (let x = 0; x <= W; x += 4) {
  ground.push(H - 40 + Math.sin(x * 0.02) * 8 + Math.sin(x * 0.05) * 4);
}

// Generate plants
for (let i = 0; i < 15; i++) {
  plants.push({
    x: 20 + Math.random() * (W - 40),
    height: 15 + Math.random() * 30,
    sway: Math.random() * Math.PI * 2,
    hue: 90 + Math.random() * 40,
    type: Math.random() < 0.3 ? 'flower' : Math.random() < 0.5 ? 'mushroom' : 'grass'
  });
}

// Initial creatures
for (let i = 0; i < 8; i++) addCreature();
// Initial food
for (let i = 0; i < 5; i++) foods.push({ x: 30 + Math.random() * (W-60), y: H - 50 + Math.random() * 10, life: 600 + Math.random() * 400 });

function addCreature() {
  const sp = species[Math.floor(Math.random() * species.length)];
  const name = names[Math.floor(Math.random() * names.length)];
  creatures.push({
    x: 30 + Math.random() * (W - 60),
    y: H - 55 + Math.random() * 10,
    vx: (Math.random() - 0.5) * sp.speed,
    vy: 0,
    species: sp,
    name: name,
    energy: 80 + Math.random() * 20,
    age: 0,
    maxAge: sp.lifespan + Math.random() * 1000,
    state: 'wander',
    stateTimer: 0,
    trail: [],
  });
  log(`${sp.emoji} ${name} appeared!`);
}

function sprinkleFood() {
  for (let i = 0; i < 6; i++) {
    foods.push({ x: 100 + Math.random() * (W-200), y: H - 80 + Math.random() * 30, life: 500 + Math.random() * 300 });
  }
  log('üåæ food sprinkled!');
}

function toggleRain() { isRaining = !isRaining; log(isRaining ? 'üåßÔ∏è it begins to rain...' : '‚òÄÔ∏è the rain stops.'); }
function toggleTime() { isNight = !isNight; log(isNight ? 'üåô night falls.' : '‚òÄÔ∏è dawn breaks.'); }

// Click to place food
c.addEventListener('click', (e) => {
  const rect = c.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (W / rect.width);
  const y = (e.clientY - rect.top) * (H / rect.height);
  foods.push({ x, y, life: 800 });
  particles.push(...Array.from({length: 5}, () => ({ x, y, vx: (Math.random()-0.5)*2, vy: -Math.random()*2, life: 30, color: '#eecc44' })));
});

function update() {
  tick++;

  // Rain
  if (isRaining && tick % 2 === 0) {
    rain.push({ x: Math.random() * W, y: -5, speed: 3 + Math.random() * 2 });
  }
  rain = rain.filter(r => { r.y += r.speed; return r.y < H; });

  // Rain grows plants
  if (isRaining && tick % 300 === 0) {
    plants.forEach(p => p.height = Math.min(p.height + 1, 50));
  }

  // Food decay
  foods = foods.filter(f => { f.life--; return f.life > 0; });

  // Particles
  particles = particles.filter(p => { p.x += p.vx; p.y += p.vy; p.vy += 0.05; p.life--; return p.life > 0; });

  // Creatures
  creatures.forEach(cr => {
    cr.age++;
    cr.energy -= 0.02;
    cr.stateTimer--;

    // Find nearby food
    let nearestFood = null, nearDist = 999;
    foods.forEach(f => {
      const d = Math.hypot(f.x - cr.x, f.y - cr.y);
      if (d < nearDist) { nearDist = d; nearestFood = f; }
    });

    if (cr.energy < 50 && nearestFood && nearDist < 120) {
      // Seek food
      cr.state = 'seek';
      const angle = Math.atan2(nearestFood.y - cr.y, nearestFood.x - cr.x);
      cr.vx += Math.cos(angle) * 0.1;
      cr.vy += Math.sin(angle) * 0.05;
      if (nearDist < 8) {
        cr.energy = Math.min(100, cr.energy + 30);
        foods.splice(foods.indexOf(nearestFood), 1);
        particles.push(...Array.from({length: 3}, () => ({ x: cr.x, y: cr.y, vx: (Math.random()-0.5)*1.5, vy: -Math.random()*1.5, life: 20, color: '#88ee66' })));
      }
    } else if (cr.stateTimer <= 0) {
      // Random behavior
      const r = Math.random();
      if (r < 0.3) { cr.state = 'rest'; cr.stateTimer = 60 + Math.random() * 120; cr.vx *= 0.1; }
      else if (r < 0.5 && isNight) { cr.state = 'sleep'; cr.stateTimer = 200 + Math.random() * 200; cr.vx = 0; }
      else { cr.state = 'wander'; cr.stateTimer = 60 + Math.random() * 100; cr.vx = (Math.random() - 0.5) * cr.species.speed; }
    }

    // Physics
    cr.vx *= 0.98;
    cr.x += cr.vx;
    cr.y += cr.vy;
    cr.vy += 0.1; // gravity
    
    // Ground
    const gIdx = Math.floor(cr.x / 4);
    const gY = ground[Math.max(0, Math.min(gIdx, ground.length-1))] - 12;
    if (cr.y > gY) { cr.y = gY; cr.vy = 0; }
    
    // Walls
    if (cr.x < 10) { cr.x = 10; cr.vx *= -1; }
    if (cr.x > W - 10) { cr.x = W - 10; cr.vx *= -1; }

    // Trail
    if (tick % 4 === 0 && cr.state !== 'sleep') cr.trail.push({ x: cr.x, y: cr.y + 4 });
    if (cr.trail.length > 20) cr.trail.shift();
  });

  // Death
  creatures = creatures.filter(cr => {
    if (cr.age > cr.maxAge || cr.energy <= 0) {
      log(`${cr.species.emoji} ${cr.name} passed away peacefully.`);
      particles.push(...Array.from({length: 8}, () => ({ x: cr.x, y: cr.y, vx: (Math.random()-0.5)*2, vy: -Math.random()*3, life: 50, color: '#ffffff' })));
      // Chance to spawn new
      if (creatures.length < 4 && Math.random() < 0.5) setTimeout(addCreature, 2000);
      return false;
    }
    return true;
  });

  // Spontaneous birth
  if (tick % 600 === 0 && creatures.length < 12 && Math.random() < 0.3) addCreature();

  if (logTimer > 0) logTimer--;
}

function draw() {
  // Sky
  const skyTop = isNight ? '#0a0a18' : '#2a3a6a';
  const skyBot = isNight ? '#1a1028' : '#6a8acc';
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, skyTop);
  grad.addColorStop(1, skyBot);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Stars (night)
  if (isNight) {
    for (let i = 0; i < 40; i++) {
      const sx = (i * 137.5 + tick * 0.01) % W;
      const sy = (i * 97.3) % (H * 0.5);
      const bright = 0.3 + 0.3 * Math.sin(tick * 0.02 + i);
      ctx.fillStyle = `rgba(255,255,240,${bright})`;
      ctx.fillRect(sx, sy, 1.5, 1.5);
    }
  }

  // Moon/Sun
  if (isNight) {
    ctx.fillStyle = 'rgba(240,230,200,0.8)';
    ctx.beginPath(); ctx.arc(500, 50, 20, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = skyTop;
    ctx.beginPath(); ctx.arc(506, 46, 18, 0, Math.PI*2); ctx.fill();
  } else {
    ctx.fillStyle = 'rgba(255,220,100,0.9)';
    ctx.beginPath(); ctx.arc(120, 60, 25, 0, Math.PI*2); ctx.fill();
  }

  // Rain
  ctx.strokeStyle = 'rgba(140,160,255,0.3)';
  ctx.lineWidth = 1;
  rain.forEach(r => { ctx.beginPath(); ctx.moveTo(r.x, r.y); ctx.lineTo(r.x - 1, r.y + 6); ctx.stroke(); });

  // Ground
  const groundGrad = ctx.createLinearGradient(0, H-50, 0, H);
  groundGrad.addColorStop(0, isNight ? '#1a2a15' : '#2a4a20');
  groundGrad.addColorStop(1, isNight ? '#0f1a0c' : '#1a3015');
  ctx.fillStyle = groundGrad;
  ctx.beginPath();
  ctx.moveTo(0, H);
  for (let i = 0; i < ground.length; i++) ctx.lineTo(i * 4, ground[i]);
  ctx.lineTo(W, H);
  ctx.fill();

  // Dirt layer
  ctx.fillStyle = isNight ? '#1a150f' : '#3a2a1a';
  ctx.fillRect(0, H - 20, W, 20);

  // Plants
  plants.forEach(p => {
    const sway = Math.sin(tick * 0.015 + p.sway) * 3;
    ctx.strokeStyle = `hsla(${p.hue}, 50%, ${isNight ? 20 : 35}%, 0.8)`;
    ctx.lineWidth = 2;
    
    const gIdx = Math.floor(p.x / 4);
    const baseY = ground[Math.max(0, Math.min(gIdx, ground.length-1))];
    
    if (p.type === 'grass') {
      for (let j = -1; j <= 1; j++) {
        ctx.beginPath();
        ctx.moveTo(p.x + j * 3, baseY);
        ctx.quadraticCurveTo(p.x + sway + j * 2, baseY - p.height * 0.6, p.x + sway * 1.5 + j, baseY - p.height);
        ctx.stroke();
      }
    } else if (p.type === 'flower') {
      ctx.beginPath();
      ctx.moveTo(p.x, baseY);
      ctx.quadraticCurveTo(p.x + sway, baseY - p.height * 0.6, p.x + sway * 1.2, baseY - p.height);
      ctx.stroke();
      ctx.fillStyle = `hsla(${(p.hue + 200) % 360}, 70%, ${isNight ? 40 : 65}%, 0.9)`;
      ctx.beginPath(); ctx.arc(p.x + sway * 1.2, baseY - p.height, 3, 0, Math.PI * 2); ctx.fill();
    } else { // mushroom
      ctx.fillStyle = `hsla(${p.hue + 280}, 40%, ${isNight ? 25 : 45}%, 0.8)`;
      ctx.fillRect(p.x - 1, baseY - p.height * 0.4, 3, p.height * 0.4);
      ctx.beginPath();
      ctx.ellipse(p.x, baseY - p.height * 0.4, 6, 4, 0, Math.PI, 0);
      ctx.fillStyle = `hsla(${(p.hue + 300) % 360}, 50%, ${isNight ? 30 : 50}%, 0.9)`;
      ctx.fill();
      // Spots
      ctx.fillStyle = `rgba(255,255,255,${isNight ? 0.2 : 0.4})`;
      ctx.beginPath(); ctx.arc(p.x - 2, baseY - p.height * 0.45, 1.5, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(p.x + 3, baseY - p.height * 0.42, 1, 0, Math.PI*2); ctx.fill();
    }
  });

  // Food
  foods.forEach(f => {
    const alpha = f.life < 100 ? f.life / 100 : 1;
    ctx.fillStyle = `rgba(220,180,60,${alpha * 0.8})`;
    ctx.beginPath(); ctx.arc(f.x, f.y, 2.5, 0, Math.PI*2); ctx.fill();
    // Glow
    ctx.fillStyle = `rgba(220,180,60,${alpha * 0.15})`;
    ctx.beginPath(); ctx.arc(f.x, f.y, 6, 0, Math.PI*2); ctx.fill();
  });

  // Creature trails
  creatures.forEach(cr => {
    ctx.strokeStyle = `rgba(${hexToRgb(cr.species.color)}, 0.1)`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    cr.trail.forEach((t, i) => { i === 0 ? ctx.moveTo(t.x, t.y) : ctx.lineTo(t.x, t.y); });
    ctx.stroke();
  });

  // Creatures
  creatures.forEach(cr => {
    const bob = Math.sin(tick * 0.08 + cr.x) * (cr.state === 'sleep' ? 0.5 : 1.5);
    const s = cr.species.size;
    
    // Body glow
    ctx.fillStyle = `rgba(${hexToRgb(cr.species.color)}, ${isNight ? 0.2 : 0.08})`;
    ctx.beginPath(); ctx.arc(cr.x, cr.y + bob, s * 2.5, 0, Math.PI*2); ctx.fill();
    
    // Body
    ctx.fillStyle = cr.species.color;
    ctx.beginPath(); ctx.arc(cr.x, cr.y + bob, s, 0, Math.PI*2); ctx.fill();
    
    // Eyes
    if (cr.state !== 'sleep') {
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(cr.x - 1.5, cr.y + bob - 1, 1, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(cr.x + 1.5, cr.y + bob - 1, 1, 0, Math.PI*2); ctx.fill();
    } else {
      // Zzz
      const zAlpha = 0.3 + 0.2 * Math.sin(tick * 0.03);
      ctx.fillStyle = `rgba(200,200,255,${zAlpha})`;
      ctx.font = '8px monospace';
      ctx.fillText('z', cr.x + 6, cr.y + bob - 8 + Math.sin(tick*0.02)*3);
    }

    // Energy bar
    const barW = 14;
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fillRect(cr.x - barW/2, cr.y + bob - s - 8, barW, 2);
    ctx.fillStyle = cr.energy > 30 ? '#66cc66' : '#cc4444';
    ctx.fillRect(cr.x - barW/2, cr.y + bob - s - 8, barW * (cr.energy/100), 2);

    // Name on hover proximity (always show dimly)
    ctx.fillStyle = `rgba(200,190,230,0.35)`;
    ctx.font = '7px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(cr.name, cr.x, cr.y + bob - s - 11);
    ctx.textAlign = 'left';
  });

  // Particles
  particles.forEach(p => {
    const alpha = p.life / 50;
    ctx.fillStyle = p.color.replace(')', `,${alpha})`).replace('rgb', 'rgba').replace('#', '');
    // Lazy hex handling
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x, p.y, 2, 2);
    ctx.globalAlpha = 1;
  });

  // Glass effect
  const glassGrad = ctx.createLinearGradient(0, 0, 0, H);
  glassGrad.addColorStop(0, 'rgba(255,255,255,0.03)');
  glassGrad.addColorStop(0.5, 'rgba(255,255,255,0)');
  glassGrad.addColorStop(1, 'rgba(0,0,0,0.05)');
  ctx.fillStyle = glassGrad;
  ctx.fillRect(0, 0, W, H);

  // Jar rim highlight
  ctx.strokeStyle = 'rgba(255,255,255,0.05)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.roundRect(1, 1, W-2, H-2, 16);
  ctx.stroke();

  // Stats
  const statsEl = document.getElementById('stats');
  statsEl.textContent = `üêõ ${creatures.length} creatures ¬∑ üåæ ${foods.length} food ¬∑ tick ${tick}`;
  
  // Log
  const logEl = document.getElementById('log');
  logEl.textContent = logTimer > 0 ? logText : '';
  logEl.style.opacity = logTimer > 0 ? Math.min(logTimer / 30, 0.5) : 0;
}

function hexToRgb(hex) {
  const r = parseInt(hex.slice(1,3), 16);
  const g = parseInt(hex.slice(3,5), 16);
  const b = parseInt(hex.slice(5,7), 16);
  return `${r},${g},${b}`;
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
